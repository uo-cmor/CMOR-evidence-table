---
title: "CMOR Evidence Table"
format:
  html:
    page-layout: full
echo: false
---

## What matters to you when choosing treatments for knee osteoarthritis?

::: {layout-ncol=2}
There are many treatment options available for the management of knee osteoarthritis.\
\
Some of them are highly effective, reducing pain and improving joint function and overall quality of life; others have limited or unclear effect on pain or disability. Some are widely available, easily accessible, and affordable for all people with osteoarthritis; others are expensive or involve long travel or waiting times to receive treatment. Some are very safe, with few or no side-effects and little risk of harm; others may have potentially severe complications.\
\
Understanding how osteoarthritis healthcare consumers, providers, policy makers, and other stakeholders trade off between these different attributes of treatments is crucial to ensure good value, effective, accessible, acceptable, and equitable care can be made available to all people with osteoarthritis.

This application presents the results of a study designed to elicit from key stakeholders the attributes of treatment considered important in choosing or recommending treatment for osteoarthritis, and their preference weights for these attributes (i.e. the relative importance of each attribute); to describe the performance of osteoarthritis treatments against the attributes, informed by high-quality clinical practice guidelines and systematic reviews of peer-reviewed research; and to prioritise interventions by assessing their performance relative to stakeholder or individual preferences.\
\
In this interactive application you can filter the interventions to be included in the analysis, alter the preference weights used to evaluate trade-offs between attributes, or select evidence specific to early-, mid-, or late-stage disease using the drop-down options menus, and switch between viewing the preference ranking plot and the underlying evidence table.
:::

```{r load-data}
suppressPackageStartupMessages(library(tidyverse))

load("data/evidenceTables.Rdata")

attrs <- names(attributeNames)

evidence <- evidenceTables_tibble %>% 
	ungroup() %>% 
	mutate(across(all_of(attrs), as.integer)) %>% 
	rename_with(\(x) paste0(x, ".level"), all_of(attrs)) %>% 
	pivot_longer(starts_with(attrs), names_to = c("attribute", ".value"), names_sep = "\\.") %>% 
	mutate(
		attribute = case_match(attribute, .default = attribute,
													 "Quality of the evidence" ~ "Quality of Evidence",
													 "Duration" ~ "Duration of Effect",
													 "Risk of mild to moderate side-effects" ~ "Risk of Mild/Moderate Harm",
													 "Risk of serious harm" ~ "Risk of Serious Harm"),
		level_weight = map2_dbl(
			attribute, level,
			\(attr, lev) attributeLevels[[as.integer(factor(attr, attrs))]][[lev]]
		),
		category = factor(
			str_remove(Intervention.detail, "Category: "),
			c("Self-management and education interventions", "Psychological interventions",
				"Exercise interventions", "Other physical therapies", "Weight management",
				"Mechanical aids and devices", "Electrotherapies",
				"Pharmacological interventions (over the counter)",
				"Pharmacological interventions (prescription medication only)", "Injectable agents",
				"Alternative medicines", "Surgical interventions")
		)
	)

ojs_define(evidence = evidence,
					 original_weights = attributeWeights)
```

```{ojs functions}
import { input } from "@jashkenas/inputs"
function radio(config = {}) {
  let {
    value: formValue,
    title,
    description,
    submit,
    options,
    disabled
  } = Array.isArray(config) ? { options: config } : config;
  options = options.map(o =>
    typeof o === "string" ? { value: o, label: o } : o
  );
  const form = input({
    type: "radio",
    title,
    description,
    submit,
    getValue: input => {
      if (input.checked) return input.value;
      const checked = Array.prototype.find.call(input, radio => radio.checked);
      return checked ? checked.value : undefined;
    },
    form: html`
      <form>
        ${options.map(({ value, label }, i) => {
          const input = html`<input type=radio name=input ${
            value === formValue ? "checked" : ""
          } style="vertical-align: top; ${
            i === 0 ? `margin-left: 1px;` : ``
          }" />`;
          input.setAttribute("value", value);
          if (disabled) input.setAttribute("value", disabled);
          const tag = html`
          <label style="display: inline-block; margin: 5px 10px 3px 0; font-size: 0.85em;">
           ${input}
           ${label}
          </label><br>`;
          return tag;
        })}
      </form>
    `
  });
  form.output.remove();
  return form;
}

function select(config = {}) {
  let {
    value: formValue,
    title,
    description,
    disabled,
    submit,
    multiple,
    size,
    options
  } = Array.isArray(config) ? { options: config } : config;
  options = options.map(o =>
    typeof o === "object" ? o : { value: o, label: o }
  );
  const form = input({
    type: "select",
    title,
    description,
    submit,
    attributes: { disabled },
    getValue: input => {
      const selected = Array.prototype.filter
        .call(input.options, i => i.selected)
        .map(i => i.value);
      return multiple ? selected : selected[0];
    },
    form: html`
      <form>
        <select name="input" ${
          multiple ? `multiple size="${size || options.length}"` : ""
        }>
          ${options.map(({ value, label,disabled }) =>
            Object.assign(html`<option>`, {
              value,
              selected: Array.isArray(formValue)
                ? formValue.includes(value)
                : formValue === value,
              disabled : disabled ? disabled : false,
              textContent: label
            })
          )}
        </select>
      </form>
    `
  });
  form.output.remove();
  return form;
}

function checkbox(config = {}) {
  let {
    value: formValue,
    title,
    description,
    submit,
    disabled,
    options
  } = Array.isArray(config) ? { options: config } : config;
  options = options.map(o =>
    typeof o === "string" ? { value: o, label: o } : o
  );
  const form = input({
    type: "checkbox",
    title,
    description,
    submit,
    getValue: input => {
      if (input.length)
        return Array.prototype.filter
          .call(input, i => i.checked)
          .map(i => i.value);
      return input.checked ? input.value : false;
    },
    form: html`
      <form>
        ${options.map(({ value, label }, i) => {
          const input = html`<input type=checkbox name=input ${
            (formValue || []).indexOf(value) > -1 ? "checked" : ""
          } style="vertical-align: top; ${
            i === 0 ? `margin-left: 1px;` : ``
          }" />`;
          input.setAttribute("value", value);
          if (disabled) input.setAttribute("disabled", disabled);
          const tag = html`<label style="display: inline-block; margin: 5px 10px 3px 0; font-size: 0.85em;">
           ${input}
           ${label}
          </label><br>`;
          return tag;
        })}
      </form>
    `
  });
  form.output.remove();
  return form;
}

function slider(config = {}) {
  let {
    min = 0,
    max = 1,
    value = (max + min) / 2,
    step = "any",
    precision = 2,
    title,
    description,
    disabled,
    getValue,
    format,
    display,
    submit
  } = typeof config === "number" ? { value: config } : config;
  precision = Math.pow(10, precision);
  if (!getValue)
    getValue = input => Math.round(input.valueAsNumber * precision) / precision;
  return input({
    type: "range",
    title,
    description,
    submit,
    format,
    display,
    attributes: { min, max, step, disabled, value },
    getValue
  });
}

function number(config = {}) {
  const {
    value,
    title,
    description,
    disabled,
    placeholder,
    submit,
    step = "any",
    min,
    max
  } =
    typeof config === "number" || typeof config === "string"
      ? { value: +config }
      : config;
  const form = input({
    type: "number",
    title,
    description,
    submit,
    attributes: {
      value,
      placeholder,
      step,
      min,
      max,
      autocomplete: "off",
      disabled
    },
    getValue: input => input.valueAsNumber
  });
  form.output.remove();
  form.input.style.width = "auto";
  form.input.style.fontSize = "1em";
  return form;
}

```

::: {.column-screen-inset .panel-input}
:::: {.columns}
::::: {.column width="30%"}
```{ojs}
viewof maxrows = {
  const element = html`<form>
	  Show top <select name="maxrows" id="maxrows">
	    <option value=5>5</option> 
	    <option value=10>10</option> 
	    <option value=25 selected>25</option> 
	    <option value=50>50</option> 
	    <option value=100>100</option> 
	  </select> rows
  </form>`;
  element.value = element.elements[0].value;
  element.elements[0].addEventListener("change", () => {
    element.value = element.elements[0].value;
    element.dispatchEvent(new Event("input", {bubbles: true}));
  });
  return element;
}
```
:::::

::::: {.column width="10%"}
```{ojs}
viewof stage = {
  const element = html`<form>
    <label><strong>Timing of<br>interventions:</strong></label><br>
    <input type="radio" name="stage" value="Overall" checked>Overall<br>
    <input type="radio" name="stage" value="Early">Early<br>
    <input type="radio" name="stage" value="Mid">Mid<br>
    <input type="radio" name="stage" value="Late">Late<br>
  </form>`
  for (let i = 0; i < element.length; i++) {
    if (element.elements[i].checked) element.value = element.elements[i].value
	  element.elements[i].addEventListener("click", () => {
	    element.value = element.elements[i].value;
	    element.dispatchEvent(new Event("input", {bubbles: true}));
	  });
  }
  return element
}
```
:::::

::::: {.column width="30%"}
```{ojs}
viewof categories = {
  const element = html`<form>
    <label><strong>Interventions:</strong></label><br>
    <button name="allInterventions" type="button">(select all)</button>
    <button name="noInterventions" type="button">(select none)</button><br>
    <label><input type="checkbox" name="categories" value="Self-management and education interventions" checked> Self-management and education interventions</label><br>
    <label><input type="checkbox" name="categories" value="Psychological interventions" checked> Psychological interventions</label><br>
    <label><input type="checkbox" name="categories" value="Exercise interventions" checked> Exercise interventions</label><br>
    <label><input type="checkbox" name="categories" value="Other physical therapies" checked> Other physical therapies</label><br>
    <label><input type="checkbox" name="categories" value="Weight management" checked> Weight management</label><br>
    <label><input type="checkbox" name="categories" value="Mechanical aids and devices" checked> Mechanical aids and devices</label><br>
    <label><input type="checkbox" name="categories" value="Electrotherapies" checked> Electrotherapies</label><br>
    <label><input type="checkbox" name="categories" value="Pharmacological interventions (over the counter)" checked> Pharmacological interventions (over the counter)</label><br>
    <label><input type="checkbox" name="categories" value="Pharmacological interventions (prescription medication only)" checked> Pharmacological interventions (prescription medication only)</label><br>
    <label><input type="checkbox" name="categories" value="Injectable agents" checked> Injectable agents</label><br>
    <label><input type="checkbox" name="categories" value="Alternative medicines" checked> Alternative medicines</label><br>
    <label><input type="checkbox" name="categories" value="Surgical interventions" checked> Surgical interventions</label><br>
  </form>`
  element.value = [];
  element.elements.namedItem("allInterventions").addEventListener("click", () => {
    element.value = []
    for (let j = 2; j < element.length; j++) {
      element.elements[j].checked = true
      element.value.push(element.elements[j].value)
    }
    element.dispatchEvent(new Event("input", {bubbles: true}));
  });
  element.elements.namedItem("noInterventions").addEventListener("click", () => {
    element.value = []
    for (let j = 2; j < element.length; j++) {
      element.elements[j].checked = false
    }
    element.dispatchEvent(new Event("input", {bubbles: true}));
  });
  for (let i = 2; i < element.length; i++) {
    if (element.elements[i].checked) element.value.push(element.elements[i].value)
	  element.elements[i].addEventListener("change", () => {
	    if (element.elements[i].checked) element.value.push(element.elements[i].value)
	    else {
	      element.value = []
	      for (let j = 2; j < element.length; j++) {
	        if (element.elements[j].checked) element.value.push(element.elements[j].value)
        }
	    };
	    element.dispatchEvent(new Event("input", {bubbles: true}));
	  });
  }
  return element
}
```
:::::

::::: {.column width="30%"}
```{ojs}
viewof weights = {
  const element = html`<form>
    <label><strong>Attribute weights:</strong></label><br>
    <label>Recommendation <input type="number" name="weight_rec" value=19> <input type="range" name="weight_rec"></label>
    <label>Quality of Evidence <input type="number" name="weight_qua" value=17.6> <input type="range" name="weight_qua"></label>
    <label>Effectiveness <input type="number" name="weight_eff" value=15> <input type="range" name="weight_eff"></label>
    <label>Duration of Effect <input type="number" name="weight_dur" value=13.2> <input type="range" name="weight_dur"></label>
    <label>Risk of Serious Harm <input type="number" name="weight_ser" value=12.8> <input type="range" name="weight_ser"></label>
    <label>Risk of Mild/Moderate Harm <input type="number" name="weight_mil" value=9.4> <input type="range" name="weight_mil"></label>
    <label>Cost <input type="number" name="weight_cos" value=6.6> <input type="range" name="weight_cos"></label>
    <label>Accessibility <input type="number" name="weight_acc" value=6.3> <input type="range" name="weight_acc"></label>
  </form>`
  element.value = [element.elements[0].value,
                   element.elements[2].value,
                   element.elements[4].value,
                   element.elements[6].value,
                   element.elements[8].value,
                   element.elements[10].value,
                   element.elements[12].value,
                   element.elements[14].value]
  for (let i = 0; i < element.length; i=i+2) {
    element.elements[i].addEventListener("change", () => {
      element.value[i/2] = element.elements[i].value
	    element.dispatchEvent(new Event("input", {bubbles: true}));
    })
  }
  return element
}

function set(input, value) {
  input.value = value;
  input.dispatchEvent(new Event("input", {bubbles: true}));
}

Inputs.button([
  ["Normalise to 100", () => {
		const sum_weights = 0
		for (let i = 0; i < 8; ++i) sum_weights += viewof weights.value[i]
		viewof weights.value[0] /= (sum_weights / 100)
		viewof weights.value[1] /= (sum_weights / 100)
		viewof weights.value[2] /= (sum_weights / 100)
		viewof weights.value[3] /= (sum_weights / 100)
		viewof weights.value[4] /= (sum_weights / 100)
		viewof weights.value[5] /= (sum_weights / 100)
		viewof weights.value[6] /= (sum_weights / 100)
		viewof weights.value[7] /= (sum_weights / 100)
		viewof weights.dispatchEvent(new Event("input", {bubbles: true}))
  }],
	["Reset", () => {
		viewof weights.value[0] = original_weights[0]
		viewof weights.value[1] = original_weights[1]
		viewof weights.value[2] = original_weights[2]
		viewof weights.value[3] = original_weights[3]
		viewof weights.value[4] = original_weights[4]
		viewof weights.value[5] = original_weights[5]
		viewof weights.value[6] = original_weights[6]
		viewof weights.value[7] = original_weights[7]
		viewof weights.dispatchEvent(new Event("input", {bubbles: true}))
  }]
])
```
:::::
::::
:::

::: {.column-screen-inset}
```{ojs}
import {aq, op} from '@uwdata/arquero'
attribute_weights = aq.table({
  attribute: ["Recommendation", "Quality of Evidence", "Effectiveness", "Duration of Effect",
              "Risk of Serious Harm", "Risk of Mild/Moderate Harm", "Cost", "Accessibility"],
  attribute_weight: weights
})
sumWeights = attribute_weights.rollup({weight: op.sum('attribute_weight')}).array('weight')
data = aq.from(transpose(evidence))
  .filter(aq.escape(d => stage == d.timing))
  .filter(aq.escape(d => categories.includes(d.category)))
  .join_left(attribute_weights, 'attribute')
  .derive({weight: aq.escape(d => d.attribute_weight * d.level_weight / sumWeights * 100)})
  .groupby('Name')
  .derive({score: op.sum('weight')})
  .ungroup()
  .orderby(aq.desc('score'), 'Name')
  .derive({rn: op.row_number()})
  .filter(aq.escape(d => d.rn <= maxrows * 8))

labels = aq.from(data)
  .groupby('Name')
  .rollup({score: op.sum('weight')})

evidenceTablePlot = Plot.plot({
  color: {
    type: "categorical",
    domain: ["Recommendation", "Quality of Evidence", "Effectiveness", "Duration of Effect", "Risk of Serious Harm", "Risk of Mild/Moderate Harm", "Cost", "Accessibility"],
    scheme: "Accent",
    legend: true
  },
  x: {domain: [0, 100]},
  marginLeft: 250,
  width: `${width}`,
  marks: [
    Plot.barX(data,
      Plot.stackX({order: ["Recommendation", "Quality of Evidence", "Effectiveness", "Duration of Effect",
                           "Risk of Serious Harm", "Risk of Mild/Moderate Harm", "Cost", "Accessibility"]},
                  {x: "weight", y: "Name", z: "attribute", fill: "attribute",
                   sort: {y: "x", reverse: true}, fillopacity: 0.3, tip: "y"})
    ),
    Plot.textX(labels, {x: (d) => (d.score + 2), y: "Name", text: (d) => (d.score).toFixed(1)})
  ]
})
```
:::
